<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hanson</title>
    <description>Hanson|Think Different</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 24 Apr 2017 21:46:34 +0800</pubDate>
    <lastBuildDate>Mon, 24 Apr 2017 21:46:34 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>test</title>
        <description>&lt;p&gt;这是一个测试页面
&lt;img src=&quot;/assets/image/test.png =100&quot; alt=&quot;TEST&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.使用CoreLocation时，requestAlwaysAuthorization(),因为要获取位置权限，所以在info.plist里要添加NSLocationAlwaysUsageDescription和NSLocationWhenInUseUsageDescription这两个授权提示的描述，不然在debug的时候是进不到delegate实现的方法的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/test.png&quot; alt=&quot;替代文本&quot; title=&quot;标题文本&quot; width=&quot;200&quot; height=&quot;100&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/08/07/test/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/08/07/test/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>swift小项目-基于CoreLoaction和MapKit的位置app</title>
        <description>&lt;p&gt;这是一个用了CoreLoaction和MapKit的一个小项目，界面是点击按钮找到当前位置并且在地图上标记出来。下面是几点注意的：&lt;/p&gt;

&lt;p&gt;1.使用CoreLocation时，requestAlwaysAuthorization(),因为要获取位置权限，所以在info.plist里要添加NSLocationAlwaysUsageDescription和NSLocationWhenInUseUsageDescription这两个授权提示的描述，不然在debug的时候是进不到delegate实现的方法的。&lt;/p&gt;

&lt;p&gt;2.下面直接贴出部分代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import CoreLocation
import MapKit

class ViewController: UIViewController , CLLocationManagerDelegate{

    @IBOutlet weak var locationLabel: UILabel!
    @IBOutlet weak var mapView: MKMapView!
    
    var locationManager: CLLocationManager!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.mapView.mapType = MKMapType.Standard
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    @IBAction func FindButtonDidPressed(sender: AnyObject) {
        
        locationManager = CLLocationManager()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.requestAlwaysAuthorization()
        locationManager.startUpdatingLocation()
        
        //创建一个MKCoordinateSpan对象，设置地图的范围（越小越精确）
        let latDelta = 0.05
        let longDelta = 0.05
        let currentLocationSpan:MKCoordinateSpan = MKCoordinateSpanMake(latDelta, longDelta)
        
        //使用当前位置
        var center:CLLocation = locationManager.location!
//        //使用自定义位置
//        let center:CLLocation = CLLocation(latitude: 32.029171, longitude: 118.788231)
        let currentRegion:MKCoordinateRegion = MKCoordinateRegion(center: center.coordinate,
                                                                  span: currentLocationSpan)
        
        //设置显示区域
        self.mapView.setRegion(currentRegion, animated: true)
        
        //创建一个大头针对象
        let objectAnnotation = MKPointAnnotation()
        objectAnnotation.coordinate = center.coordinate
        objectAnnotation.title = center.description
        objectAnnotation.subtitle = &quot;&quot;
        self.mapView.addAnnotation(objectAnnotation)
        
    }
    
    func locationManager(manager: CLLocationManager, didFailWithError error: NSError) {
    
        self.locationLabel.text = &quot;更新位置发生错误：&quot; + error.description
    }
    
    func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        
        CLGeocoder().reverseGeocodeLocation(manager.location!, completionHandler: {(placemarks, error)-&amp;gt;Void in
            
            if (error != nil) {
                self.locationLabel.text = &quot;Reverse geocoder failed with error&quot; + error!.localizedDescription
                return
            }
            
            if placemarks!.count &amp;gt; 0 {
                let pm = placemarks![0]
                self.displayLocationInfo(pm)
            } else {
                self.locationLabel.text = &quot;Problem with the data received from geocoder&quot;
            }
        })
    }
    
    func displayLocationInfo(placemark:CLPlacemark?){
        
        if let containsPlacemark = placemark {
            
            locationManager.stopUpdatingLocation()
            
            let locality = (containsPlacemark.locality != nil) ? containsPlacemark.locality : &quot;&quot;
            let postalCode = (containsPlacemark.postalCode != nil) ? containsPlacemark.postalCode : &quot;&quot;
            let administrativeArea = (containsPlacemark.administrativeArea != nil) ? containsPlacemark.administrativeArea : &quot;&quot;
            let country = (containsPlacemark.country != nil) ? containsPlacemark.country : &quot;&quot;
            
            self.locationLabel.text = locality! + &quot;-&quot; +  postalCode! + &quot;-&quot; +  administrativeArea! + &quot;-&quot; +  country!
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 23 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/03/23/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8ECoreLoaction%E5%92%8CMapKit%E7%9A%84%E4%BD%8D%E7%BD%AEapp/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/03/23/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8ECoreLoaction%E5%92%8CMapKit%E7%9A%84%E4%BD%8D%E7%BD%AEapp/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>swift小项目-图片横排展示小结</title>
        <description>&lt;p&gt;这是一个页面用了UICollectionView，然后配合UIVisualEffectView展示出毛玻璃效果的一个小demo。下面是几点注意的：&lt;/p&gt;

&lt;p&gt;1.注意在StoryBoard里把dataSource和delegate通过referencing Outlets关联，然后在代码里使用extension方法实现datasoruce方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CollectionViewController: UIViewController {

    @IBOutlet weak var collectView: UICollectionView!
    
    private var contents = Content.createContents()
    let CellIdentifier = &quot;contentCell&quot;
    
    override func viewDidLoad() {
        super.viewDidLoad()
    }

    override func preferredStatusBarStyle() -&amp;gt; UIStatusBarStyle {
        return UIStatusBarStyle.LightContent  //设置状态栏字符为白色
    }
    
    //用struct定义
    private struct Storyboard {
        static let CellIdentifier = &quot;contentCell&quot;
    }

}

extension CollectionViewController : UICollectionViewDataSource{
    
    func numberOfSectionsInCollectionView(collectionView: UICollectionView) -&amp;gt; Int {
        return 1
    }
    
    func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&amp;gt; Int {
        return contents.count
    }
    
    func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&amp;gt; UICollectionViewCell {
        let collectionViewCell = collectionView.dequeueReusableCellWithReuseIdentifier(CellIdentifier /*Storyboard.CellIdentifier*/, forIndexPath: indexPath) as! CollectionViewCell
        
        collectionViewCell.content = contents[indexPath.item]
        
        return collectionViewCell
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.设置UICollectionViewCell之间的距离，可以在StoryBoard里找到Collection View Flow Layout这个选项，在Size Inspector里，找到Section Insets 的选项，里面的Left 和 Right 就是cell之间的距离&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/03/19/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E7%89%87%E6%A8%AA%E6%8E%92%E5%B1%95%E7%A4%BA%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/03/19/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E7%89%87%E6%A8%AA%E6%8E%92%E5%B1%95%E7%A4%BA%E5%B0%8F%E7%BB%93/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>swift小项目-播放本地视频小结</title>
        <description>&lt;p&gt;这是一个页面用了UITableview，然后播放本地视频的一个小app，这次实现起来有几点注意的：&lt;/p&gt;

&lt;p&gt;1.继承UIViewController, UITableViewDataSource, UITableViewDelegate的viewcontroller要注意实现必要的方法，以及
在viewDidLoad()这个方法里要添加内容如下，不然的话运行起来界面看到的是空白。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func viewDidLoad() {
    super.viewDidLoad()
    //注意这里一定要添加datasource和delegate
    videoView.dataSource = self
    videoView.delegate   = self
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用本地文件时，记得在项目里的Targets -&amp;gt; Build Phases -&amp;gt; Copy Bundle Resources里面导入相对应的资源文件，不然在使用NSBundle.mainBundle().pathForResource(name: String?, ofType: String?)
是会返回空的地址。&lt;/p&gt;

&lt;p&gt;3.播放本地视频的简要方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var playerViewController = AVPlayerViewController()
	var playerView           = AVPlayer()
    
    let videoPath = NSBundle.mainBundle().pathForResource(&quot;eat&quot;, ofType: &quot;mp4&quot;)
    
    print(&quot;video path is &quot;+videoPath!)
    
    playerView = AVPlayer(URL: NSURL(fileURLWithPath: videoPath!))
    
    playerViewController.player = playerView
    
    self.presentViewController(playerViewController, animated: true){
        self.playerViewController.player?.play()
    }
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/03/04/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E6%92%AD%E6%94%BE%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/03/04/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E6%92%AD%E6%94%BE%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E5%B0%8F%E7%BB%93/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>swift小项目-自定义字体</title>
        <description>&lt;p&gt;这是一个可以改变页面上显示字体的小app，其中用了UITableview。
1.有一个很奇怪的报错：
Terminating app due to uncaught exception ‘CALayerInvalid’, reason: ‘layer &amp;lt;CALayer: 0x7fda42c66e30&amp;gt; is a part of cycle in its layer tree’&lt;/p&gt;

&lt;p&gt;这个很奇怪的报错，通过网上查找发现，只要去到storybord那里，在Connections Inspector里把accessoryView 关联的outlet删掉就不会报错了！&lt;/p&gt;

&lt;p&gt;2.使用自定义字体的时候，把字体文件添加进入项目后，要去到Build Phases—Copy Bundle Resources，确保刚添加的字体文件在列表中，否则需要手动加到这里面。然后要去info.plist文件里添加Fonts provided by application这一项，然后把刚刚添加进去的字体文件的文件名加在这里，记住要加上文件格式的后缀，比如.ttf&lt;/p&gt;

&lt;p&gt;3.一种使数字循环的方法：
	var fontName = [“Gaspar Regular”,”MFTongXin_Noncommercial-Regular”, “MFJinHei_Noncommercial-Regular”, “MFZhiHei_Noncommercial-Regular”]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fontIndex = 0

@IBOutlet weak var changeButton: UIButton!
@IBOutlet weak var tableFontView: UITableView!

@IBAction func ToChangeFont(sender: AnyObject) {
    
    fontIndex = (fontIndex + 1) % 4   //用整除的方法可以使数字循环，达到每次点击button切换一种字体
    tableFontView.reloadData()
    print(fontIndex)
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 29 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/02/29/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%88%87%E6%8D%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/02/29/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%88%87%E6%8D%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%B0%8F%E7%BB%93/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>swift小项目-小计算器学习小结</title>
        <description>&lt;p&gt;这是一个超简单的计算器app，学习过程中有几点觉得可以记录一下的,具体注意的点见下面代码片段的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@IBOutlet weak var textOne: UITextField!
@IBOutlet weak var textTwo: UITextField!
@IBOutlet weak var resultLabel: UILabel!

//self.textOne.text.toInt()这是旧的写法，会报错
var num1 = Int(self.textOne.text!)

//下面的两种方法判断UITextField有没有值
if(self.textOne.text!.isEmpty){
	num1 = 0
}
if(!self.textTwo.hasText()){
	num2 = 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个报错记录一下 “Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:”&lt;/p&gt;

&lt;p&gt;原因是初始ViewController没有指定，可以在StoryBorder里在ViewController的属性那里把『Is Initial View Controller里勾上』&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/02/27/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/02/27/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>swift小项目-简易秒表simpleStopWatch</title>
        <description>&lt;p&gt;前天在github看到一个30天一天一个swift的项目。想想自己也可以试试，于是便有了今天的swift小项目。下面是几个总结&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用autolayout时，在storyborad里为各个组件添加约束的时候，记住不要先写死某些长度宽度，而是要用各种约束去把宽度长度定死，最后才加上一些自己需要的长宽约束。用这种思维会清晰很多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在用ctrl+拖动的方式绑定到代码里，要注意命名最好一开始就想好，不然以后改名字的时候，这些绑定要重新删除再绑定，不然会报 “setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key name” 这样一种错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以用『String(format: “%.1f”, countNumber)』这种方式来将double类型格式化显示你要展示的String类型&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码可以在我的github看到&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/02/22/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E7%AE%80%E6%98%93%E7%A7%92%E8%A1%A8simpleStopWatch/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/02/22/swift%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E7%AE%80%E6%98%93%E7%A7%92%E8%A1%A8simpleStopWatch/</guid>
        
        <category>swift</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
